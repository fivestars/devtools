#! /bin/bash

# Simple DAPI command-line client for making single calls to various environments and colos.
#
# Any command-line parameter to the script can be configured via the ~/.dapirc file.
# If a configuration is specified both in the .dapirc file and on the command-line,
# the command-line value takes precedence.
#
# Example:
#  # .dapirc
#  DAPI_SCHEME=https
#  DAPI_PORT=
#  DAPI_CONTEXT=
#  DAPI_APPID=100033
#  DAPI_APPSECRET=d15d6a6ebe74c0e774d64e559b39d29844e0667d_zdev_prod
#  DAPI_NETWORK=1
#  DAPI_USERID=100002218754100
#  DAPI_SNTOKEN=AAAC7nmYjV7IBACmXItMa2KhLwX6wbNdWwTZChxw4542rKZBAbeNlXtKfXAZCXAh2rqufZCZB7Nd27xVgq7rpzPeD5JafiztO2odiwVTmepz26I4f524Nz
#  DAPI_ZTOKEN=
#  DAPI_ZID=31682585134
#  DAPI_STRICTSSL=false
#
#  # These values can be configured per environment
#  DAPI_APPID_LOCAL=
#  DAPI_APPID_STAGING=
#  DAPI_APPID_RSTAGING=
#  DAPI_APPID_PROD=
#  DAPI_APPSECRET_LOCAL=
#  DAPI_APPSECRET_STAGING=
#  DAPI_APPSECRET_RSTAGING=
#  DAPI_APPSECRET_PROD=
#  DAPI_ZTOKEN_LOCAL=
#  DAPI_ZTOKEN_STAGING=
#  DAPI_ZTOKEN_RSTAGING=
#  DAPI_ZTOKEN_PROD=
#  DAPI_ZID_LOCAL=
#  DAPI_ZID_STAGING=
#  DAPI_ZID_RSTAGING=
#  DAPI_ZID_PROD=
#

# Workaround for bash 3 not having associative arrays
# Provides set, get, and get keys functionality
#    set:      map <mapname> <keyname> <<< <value>
#    get:      map <mapname> <keyname>
#    get keys: map <mapname>
function map {
	local KEYS

	if [[ -n $2 ]]; then
		if [[ -t 0 ]]; then
			# retrieve
			eval echo "\$BASHMAP${1}_${2}"
		else
			# store key
			eval KEYS=\$BASHMAP${1}keys
			if [[ $KEYS != "$2 "* && $KEYS != *" $2 "* && $KEYS != *" $2" ]]; then
				read BASHMAP${1}keys <<< "$KEYS $2"
			fi

			# store mapping
			read BASHMAP${1}_${2}
		fi
	else
		eval echo \$BASHMAP${1}keys
	fi
}

function dapi_host {
	local ENV COLO DOMAIN PORT

	if [[ -n $DAPI_COLO ]]; then
		[[ -n $DAPI_ENV ]] && ENV=_$DAPI_ENV || ENV=_PROD
		COLO=_$DAPI_COLO
	else
		[[ -n $DAPI_ENV ]] && ENV=_$DAPI_ENV
	fi

	eval DOMAIN=\${DAPI_HOST${ENV}${COLO}:-api.zynga.com}

	if [[ -z $DAPI_COLO && $DAPI_ENV != LOCAL && -z $DAPI_HOST ]]; then
		$DAPI_ONE && DOMAIN=one.$DOMAIN || DOMAIN=${METHOD%%.*}.${DOMAIN}
	elif [[ -n $DAPI_COLO && -z $DAPI_HOST ]]; then
		$DAPI_ONE && DOMAIN=one.$DOMAIN
	fi

	if [[ -n $DAPI_PORT ]]; then
		PORT=":$DAPI_PORT"
	elif [[ "$DAPI_ENV" == "LOCAL" ]]; then
		PORT=":8015"
	fi

	echo ${DOMAIN}${PORT}
}

function dapi {
	[[ -n $DAPI_XDEBUGKEY ]] && local XDEBUG=" -d XDEBUG_SESSION_START=$DAPI_XDEBUGKEY"
	local CURL=$(echo curl -g ${DAPI_CURL_OPTS[@]} ${STRICTSSL} -d v=1.2 \
				 -d "'"'p={"c": [{"m": "'$METHOD'", "al": '$LIST'}]'$TOKEN'}'"'${XDEBUG}" \
				 ${DAPI_SCHEME:-https}://$(dapi_host))
	# Display and make the call
	$DAPI_QUIET || echo "$CURL"
	! $DAPI_DRYRUN && ( echo && eval $CURL && echo ) || $DAPI_DRYRUN
}

# Parse system and user configs, if present
[[ -e /etc/dapi-client-bash/.dapirc ]] && . /etc/dapi-client-bash/.dapirc
[[ -e ~/.dapirc ]] && . ~/.dapirc
DAPI_HOST_PROD=${DAPI_HOST_PROD:-api.zynga.com}
DAPI_HOST_PROD_ZC1=${DAPI_HOST_PROD_ZC1:-zc1.api.zynga.com}
DAPI_HOST_PROD_ZC2=${DAPI_HOST_PROD_ZC2:-zc2.api.zynga.com}
DAPI_HOST_RSTAGING=${DAPI_HOST_RSTAGING:-api.release-staging.zynga.com}
DAPI_HOST_RSTAGING_ZC1=${DAPI_HOST_RSTAGING_ZC1:-zc1.api.release-staging.zynga.com}
DAPI_HOST_RSTAGING_ZC2=${DAPI_HOST_RSTAGING_ZC2:-zc2.api.release-staging.zynga.com}
DAPI_HOST_STAGING=${DAPI_HOST_STAGING:-api.staging.zynga.com}
DAPI_HOST_STAGING_ZC1=${DAPI_HOST_STAGING_ZC1:-zc1.api.staging.zynga.com}
DAPI_HOST_STAGING_ZC2=${DAPI_HOST_STAGING_ZC2:-zc2.api.staging.zynga.com}
DAPI_HOST_LOCAL=${DAPI_HOST_LOCAL:-localhost}
DAPI_CONTEXT=${DAPI_CONTEXT:-public}
DAPI_DRYRUN=${DAPI_DRYRUN:-false}
DAPI_ONE=${DAPI_ONE:-false}
DAPI_QUIET=${DAPI_QUIET:-false}
while getopts ":S:E:C:OH:P:c:a:s:n:u:t:z:T:krdxX:o:qh" OPT; do
	case $OPT in
		S) DAPI_SCHEME=$OPTARG;;
		E) DAPI_ENV=$(echo $OPTARG | tr '[:lower:]' '[:upper:]')
		   [[ PROD == ${DAPI_ENV}* ]] && DAPI_ENV=PROD
		   [[ RSTAGING == ${DAPI_ENV}* ]] && DAPI_ENV=RSTAGING && DAPI_STRICTSSL=${DAPI_STRICTSSL:-false} && DAPI_SCHEME=${DAPI_SCHEME:-http}
		   [[ STAGING == ${DAPI_ENV}* ]] && DAPI_ENV=STAGING && DAPI_STRICTSSL=${DAPI_STRICTSSL:-false} && DAPI_SCHEME=${DAPI_SCHEME:-http}
		   [[ LOCAL == ${DAPI_ENV}* ]] && DAPI_ENV=LOCAL && DAPI_PORT=${DAPI_PORT:-8015} && DAPI_STRICTSSL=${DAPI_STRICTSSL:-false} && DAPI_SCHEME=${DAPI_SCHEME:-http}
		   ;;
		C) DAPI_COLO=$OPTARG ;;
		O) DAPI_ONE=true; DAPI_CURL_OPTS=( ${DAPI_CURL_OPTS[@]} "-H 'X-Dapi-One;'" ); DAPI_STRICTSSL=false ;;
		H) DAPI_ENV=; DAPI_COLO=; DAPI_COLOS=; DAPI_HOST=$OPTARG ;;
		P) DAPI_PORT=$OPTARG ;;
		c) DAPI_CONTEXT=$(echo $OPTARG | tr '[:lower:]' '[:upper:]')
		   [[ PUBLIC == ${DAPI_CONTEXT}* ]] && DAPI_CONTEXT=pub;
		   [[ USER == ${DAPI_CONTEXT}* ]] && DAPI_CONTEXT=user;
		   [[ APPLICATION == ${DAPI_CONTEXT}* ]] && DAPI_CONTEXT=app ;;
		a) DAPI_APPID=$OPTARG; eval DAPI_APPID_{LOCAL,STAGING,RSTAGING,PROD}= ;;
		s) DAPI_APPSECRET=$OPTARG; eval DAPI_APPSECRET_{LOCAL,STAGING,RSTAGING,PROD}= ;;
		n) DAPI_NETWORK=$OPTARG ;;
		u) DAPI_USERID=$OPTARG ;;
		t) DAPI_SNTOKEN=$OPTARG ;;
		z) DAPI_ZID=$OPTARG; eval DAPI_ZID_{LOCAL,STAGING,RSTAGING,PROD}=;;
		T) DAPI_ZTOKEN=$OPTARG; eval DAPI_ZTOKEN_{LOCAL,STAGING,RSTAGING,PROD}=;;
		k) DAPI_STRICTSSL=false ;;
		r) [[ -e ~/.dapirc ]] && cat ~/.dapirc; exit;;
		d) DAPI_DRYRUN=true ;;
		x) DAPI_XDEBUGKEY=$USER ;;
		X) DAPI_XDEBUGKEY=$OPTARG ;;
		o) DAPI_CURL_OPTS=( ${DAPI_CURL_OPTS[@]} $OPTARG ) ;;
		q) $DAPI_QUIET && DAPI_QUIET=false || DAPI_QUIET=true;;
		h)
			echo 'Usage: dapi [options] plugin.method --[-]arg0 val0 val1... --[-]arg1...'
			echo
			echo 'Options:'
			echo '  -S http|https       The HTTP URL scheme. (default: https)'
			echo '                      (dapirc: DAPI_SCHEME=HTTP|HTTPS)'
			echo
			echo '  -E p[rod]|r[staging]|s[taging]|l[ocal] The environment to target. (default: prod)'
			echo '                                         (dapirc: DAPI_ENV=PROD|STAGING|RSTAGING|LOCAL)'
			echo
			echo '  -C z[c1]|zc2|a[ll] The colo to target.'
			echo '                           Use '"'"'all'"'"' to make the same call to each colo in sequence'
			echo '                           (dapirc: DAPI_COLOS="[ZC1] [ZC2]")'
			echo
			echo '  -O                  Uses the one-node domain'
			echo
			echo '  -H <domain>         The DAPI endpoint. (default: api.zynga.com)'
			echo '                      If provided, overrides -E and -C options.'
			echo '                      (dapirc: DAPI_HOST=<domain>)'
			echo
			echo '  -P <port>           The DAPI endpoint port.'
			echo '                      If -E indicates the local env, defaults to 8015.'
			echo '                      (dapirc: DAPI_PORT=<port>)'
			echo
			echo '  -c a[pp]|u[ser]|p[ub] The auth context to use. (default: pub)'
			echo '                        (dapirc: DAPI_CONTEXT=pub|app|user)'
			echo
			echo '  -a <zdc app id>     The app'"'"'s ZDC id from developers.zynga.com.'
			echo '                      (dapirc: DAPI_APPID=<zdc app id>)'
			echo
			echo '  -s <zdc app secret> The app'"'"'s ZDC secret from developers.zynga.com.'
			echo '                      (dapirc: DAPI_APPSECRET=<zdc app secret>)'
			echo
			echo '  -n <snid>           The network id of the given user session.'
			echo '                      (dapirc: DAPI_NETWORK=<snid>)'
			echo
			echo '  -u <snuid>          The user'"'"'s external network user id (ie. FB id).'
			echo '                      (dapirc: DAPI_USERID=<snuid>)'
			echo
			echo '  -t <sntoken>        The user'"'"'s external network access token.'
			echo '                      (dapirc: DAPI_SNTOKEN=<sntoken>)'
			echo
			echo '  -z <zid>            Replaces snid:snuid in token.'
			echo '                      You must still provide snid and snuid.'
			echo '                      (dapirc: DAPI_ZID=<zid>)'
			echo
			echo '  -T <ztoken>         Zynga user token.'
			echo '                      This overrides all of -anuzt if using user context.'
			echo '                      (dapirc: DAPI_ZTOKEN=<ztoken>)'
			echo
			echo '  -k                  Ignore ssl cert errors.'
			echo '                      (dapirc: DAPI_STRICTSSL=true|false)'
			echo
			echo '  -x                  Set the XDebug IDE key to $USER.'
			echo '                      (dapirc: DAPI_XDEBUGKEY=$USER)'
			echo
			echo '  -X <idekey>         Set the XDebug IDE key to <idekey>.'
			echo '                      (dapirc: DAPI_XDEBUGKEY=<idekey>)'
			echo
			echo '  -o <curl opt>       Set a curl option'
			echo
			echo '  -r                  Display the contents of your .dapirc file and exit.'
			echo
			echo '  -q                  Do not display the curl command.'
			echo
			echo '  -h                  Display this help and exit.'
			echo
			echo 'Examples:'
			echo '  dapi zids.map --uids '"'"'"31682585134"'"'"', --fromNetwork '"'"'"zynga"'"'"''
			echo '  dapi zids.map ---uids 31682585134, ---fromNetwork zynga'
			echo '  dapi -c app friends.get --zid '"31682585134"' ---snid 18'
			echo
			echo 'Method Arguments:'
			echo '  Provide arguments by prepending their names with "--". Each subsequent'
			echo '  command-line argument not prefixed with -- will be associated with the'
			echo '  latest named argument. If "---" is used as the prefix, the value will'
			echo '  be encoded as JSON strings in the request'
			echo
			echo '  Values with will be copied literally into the payload. This means string values'
			echo '  must be placed within surrounding quotes unless you use the "---" argument name'
			echo '  prefix.'
			echo '    --foo '"'"'"string val"'"'"''
			echo '    ---foo "string val"'
			echo '        => {"foo": "string val"}'
			echo
			echo '    --fooList '"'"'[1234, "abcd", {}]'"'"''
			echo '        => {"fooList": [1234, "abcd", {}]}'
			echo
			echo '    --fooObject: '"'"'{"key": "value", "numeric": 321}'"'"''
			echo '        => {"fooObject": {"key": "value", "numeric": 321}}'
			echo
			echo '  If multiple values are provided for an argument, they will be JSON-encoded'
			echo '  as a list in the payload. Commas between values are optional.'
			echo '    --fooList '"'["'"my string value", 1234, []]'"'"'           # Literal string'
			echo '    --fooList '"'"'"my string value"'"'"' 1234 []               # Multiple values'
			echo '    --fooList '"'"'"my string value"'"'"', 1234, []             # Optional commas'
			echo '    --fooList '"'"'"my string value"'"'"' --fooList 1234, []    # Multiple values'
			echo '    ---fooList "my string value" --fooList 1234, []             # String shorthand'
			echo '        => {"fooList": ["my string value", 1234, []]}'
			echo
			echo '  If you want to use this alternative form for a list with a single value,'
			echo '  place a comma after your value:'
			echo '    --fooList '"'"'"single value in list"'"'"','
			echo '    ---fooList "single value in list",'
			echo '        => {"fooList": ["single value"]}'
			echo
			echo '    --fooList 7,'
			echo '        => {"fooList": [7]}'
			exit
			;;
	esac
done
shift $((OPTIND-1))

DAPI_COLO=$(echo $DAPI_COLO | tr '[:lower:]' '[:upper:]');
[[ -n $DAPI_COLO && ZC1 == $DAPI_COLO* ]] && DAPI_COLO=ZC1;
[[ -n $DAPI_COLO && ALL == $DAPI_COLO* ]] && DAPI_COLOS="ZC1 ZC2" && DAPI_COLO=;

$DAPI_STRICTSSL && STRICTSSL= || STRICTSSL="-k"

case $DAPI_CONTEXT in
	app|user|pub|public);;
	*) echo "Invalid auth context. Must be one of: app, user, public";;
esac

[[ "$1" == *.* ]] || { echo "Must specify plugin.method" && exit 1; }
METHOD=$1
shift

# Grab arguments from the command line
while [[ $# > 0 ]]; do
	if [[ "$1" == --* ]]; then
		KEY=${1#--}; shift
		while [[ $# > 0 && "$1" != --* ]]; do
			[[ -z ${1##*,} ]] && COMMA=',' || COMMA=
			[[ "$KEY" == -* ]] && VALUE="\"${1%,}\"" || VALUE="${1%,}"
			VALUE=$(echo "$VALUE$COMMA" | sed -e 's/|/||/g' -e 's/ /|s/g')
			map args ${KEY#-} <<< "$(map args ${KEY#-}) $VALUE"
			shift
		done
	else
		echo "Provide arguments as --argname <values...>" >&2
		exit 1
	fi
done

# Build our argument list string
LIST="{"
for ARG in $(map args); do
	[[ $LIST == "{" ]] && LIST="{\"$ARG\": " || LIST="$LIST, \"$ARG\": "

	ELEMENTS=$(map args $ARG)

	COUNT=$(echo -n "${ELEMENTS//[^ ]}" | wc -c)
	( [[ $COUNT > 0 ]] || grep -q ', \+\|,$' <<< ${ELEMENTS}) && ISLIST=true || ISLIST=false

	$ISLIST && LIST="$LIST ["

	CONT=false
	for ELEMENT in $ELEMENTS; do
		$CONT && LIST="$LIST, " || CONT=true
		LIST="$LIST$(echo ${ELEMENT%,} | sed -e 's/|s/ /g' -e 's/||/|/g')"
	done

	$ISLIST && LIST="$LIST]"
done
LIST="${LIST}}"

# Determine the correct settings for the desired environment
eval DAPI_APPID=\${DAPI_APPID_${DAPI_ENV:-PROD}:-${DAPI_APPID}}
eval DAPI_APPSECRET=\${DAPI_APPSECRET_${DAPI_ENV:-PROD}:-${DAPI_APPSECRET}}
eval DAPI_ZTOKEN=\${DAPI_ZTOKEN_${DAPI_ENV:-PROD}:-${DAPI_ZTOKEN}}
eval DAPI_ZID=\${DAPI_ZID_${DAPI_ENV:-PROD}:-${DAPI_ZID}}

# Build our token according to the specified auth context
if [[ $DAPI_CONTEXT == "app" ]]; then
	[[ -z $DAPI_APPID ]] && echo "Must specify an app id" >&2 && exit 1
	[[ -z $DAPI_APPSECRET ]] && echo "Must specify the app secret" >&2 && exit 1
	TOKEN=', "t": {"appId": "'$DAPI_APPID'", "snId": "'$DAPI_NETWORK'", "secret": "'$DAPI_APPSECRET'"}'
elif [[ $DAPI_CONTEXT == "user" ]]; then
	if [[ -n $DAPI_ZTOKEN ]]; then
		TOKEN=", \"t\": \"$DAPI_ZTOKEN\""
	else
		[[ -z $DAPI_APPID ]] && echo "Must specify an app id" >&2 && exit 1

		# Assuming FB for now
		[[ -z $DAPI_USERID ]] && echo "Must provide -u <snuid> for user auth context" >&2 && exit 1
		[[ -z $DAPI_SNTOKEN ]] && echo "Must provide -t <access_token> for user auth context" >&2 exit 1

		[[ -n $DAPI_ZID ]] && TUSERID=$DAPI_ZID || TUSERID=$DAPI_NETWORK:$DAPI_USERID

		TOKEN=', "t": {
		 "appId": "'$DAPI_APPID'", "snId": "'$DAPI_NETWORK'", "userId": "'$TUSERID'",
		 "session": {"access_token": "'$DAPI_SNTOKEN'", "user_id": "'$DAPI_USERID'"}
		}'
	fi
else
	TOKEN=
fi

if [[ -n $DAPI_COLOS && $DAPI_ENV != LOCAL ]]; then
	for DAPI_COLO in $DAPI_COLOS; do
		echo "--- $DAPI_COLO ---"; dapi; R=$?; RESULT=(${RESULT[@]} $R); [[ $R != 0 ]] && F=$R; echo
	done
	[[ -n $F ]] && echo ${RESULT[@]}; exit ${F:-0}
else
	dapi
fi
